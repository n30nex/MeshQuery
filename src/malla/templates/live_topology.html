{% extends "base.html" %}
{% from "components/sidebar_macros.html" import sidebar_container, selected_details_section, search_section, controls_section, stats_section, legend_section, sidebar_styles %}

{% block title %}Live Packet Topology - Malla{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/network-graph.css') }}">
{{ sidebar_styles() }}
<style>
    .live-topology-container {
        position: relative;
        width: 100%;
        height: 100vh;
        background: #1a1a1a;
        overflow: hidden;
    }

    .network-graph {
        width: 100%;
        height: 100%;
        position: relative;
    }

    .packet-animation {
        position: absolute;
        width: 8px;
        height: 8px;
        background: #00ff88;
        border-radius: 50%;
        box-shadow: 0 0 10px #00ff88;
        z-index: 1000;
        pointer-events: none;
    }

    .node-pulse {
        animation: pulse 0.5s ease-in-out;
    }

    @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.3); }
        100% { transform: scale(1); }
    }

    .packet-trail {
        position: absolute;
        width: 2px;
        background: linear-gradient(90deg, #00ff88, transparent);
        z-index: 999;
        pointer-events: none;
    }

    .live-stats {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 15px;
        border-radius: 8px;
        color: white;
        z-index: 1001;
        min-width: 200px;
    }

    .live-stats h6 {
        margin-bottom: 10px;
        color: #00ff88;
    }

    .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 5px;
    }

    .live-controls {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 1001;
    }

    .live-controls .btn {
        margin-right: 10px;
        margin-bottom: 10px;
    }

    .packet-counter {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 10px 15px;
        border-radius: 8px;
        color: white;
        z-index: 1001;
    }

    .packet-counter .counter-value {
        font-size: 24px;
        font-weight: bold;
        color: #00ff88;
    }
</style>
{% endblock %}

{% block content %}
<!-- Override the base template's container to make this page full-width/full-height -->
</div> <!-- Close the base template's container -->

<div class="live-topology-container">
    <!-- Live Controls -->
    <div class="live-controls">
        <button id="playPauseBtn" class="btn btn-success">
            <i class="bi bi-play-fill"></i> Start Live
        </button>
        <button id="clearAnimationsBtn" class="btn btn-outline-warning">
            <i class="bi bi-trash"></i> Clear
        </button>
        <button id="toggleNodesBtn" class="btn btn-outline-info">
            <i class="bi bi-eye"></i> Show Nodes
        </button>
    </div>

    <!-- Live Stats -->
    <div class="live-stats">
        <h6><i class="bi bi-activity"></i> Live Stats</h6>
        <div class="stat-item">
            <span>Active Nodes:</span>
            <span id="activeNodesCount">0</span>
        </div>
        <div class="stat-item">
            <span>Packets/sec:</span>
            <span id="packetsPerSecond">0</span>
        </div>
        <div class="stat-item">
            <span>Total Packets:</span>
            <span id="totalPackets">0</span>
        </div>
        <div class="stat-item">
            <span>Live Time:</span>
            <span id="liveTime">00:00</span>
        </div>
    </div>

    <!-- Packet Counter -->
    <div class="packet-counter">
        <div class="counter-value" id="packetCounter">0</div>
        <div>Live Packets</div>
    </div>

    <!-- Main Graph Area -->
    <div class="graph-main">
        <div id="loadingSpinner" class="loading-overlay">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2 text-muted">Building live topology...</p>
        </div>
        <div id="networkGraph" class="network-graph"></div>
        <div id="graphError" class="error-overlay" style="display: none;">
            <i class="bi bi-exclamation-triangle"></i>
            <p class="mt-2">Error loading topology data</p>
        </div>
    </div>
</div>

<!-- Sidebar -->
{% call sidebar_container("sidebar", "Live Topology", "bi bi-lightning", "toggleSidebar") %}
    {{ selected_details_section("clearSelection") }}

    <!-- Live Settings -->
    <div class="sidebar-section">
        <h6><i class="bi bi-gear"></i> Live Settings</h6>
        <div class="mb-3">
            <label for="animationSpeed" class="form-label">Animation Speed</label>
            <input type="range" class="form-range" id="animationSpeed" min="0.5" max="3" step="0.1" value="1">
            <small class="text-muted">Speed: <span id="speedValue">1.0x</span></small>
        </div>
        <div class="mb-3">
            <label for="packetSize" class="form-label">Packet Size</label>
            <input type="range" class="form-range" id="packetSize" min="4" max="16" step="2" value="8">
            <small class="text-muted">Size: <span id="sizeValue">8px</span></small>
        </div>
        <div class="mb-3">
            <label for="trailLength" class="form-label">Trail Length</label>
            <input type="range" class="form-range" id="trailLength" min="0" max="100" step="10" value="50">
            <small class="text-muted">Length: <span id="trailValue">50%</span></small>
        </div>
    </div>

    <!-- Packet Filters -->
    <div class="sidebar-section">
        <h6><i class="bi bi-funnel"></i> Packet Filters</h6>
        <form id="packetFilterForm">
            <div class="mb-3">
                <label for="packetType" class="form-label">Packet Type</label>
                <select class="form-select form-select-sm" id="packetType" name="packetType">
                    <option value="">All Types</option>
                    <option value="POSITION_APP">Position</option>
                    <option value="TELEMETRY_APP">Telemetry</option>
                    <option value="TRACEROUTE_APP">Traceroute</option>
                    <option value="NODEINFO_APP">Node Info</option>
                </select>
            </div>
            <div class="mb-3">
                <label for="minSnr" class="form-label">Min SNR (dB)</label>
                <input type="number" class="form-control form-control-sm" id="minSnr" name="minSnr" value="-20" step="1">
            </div>
            <div class="mb-3">
                <label for="maxHops" class="form-label">Max Hops</label>
                <input type="number" class="form-control form-control-sm" id="maxHops" name="maxHops" value="5" min="0" max="10">
            </div>
        </form>
    </div>

    <!-- Node Legend -->
    <div class="sidebar-section">
        <h6><i class="bi bi-info-circle"></i> Legend</h6>
        <div class="legend-item">
            <div class="legend-color" style="background: #00ff88;"></div>
            <span>Packet Animation</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #ff6b6b;"></div>
            <span>Broadcast Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #4ecdc4;"></div>
            <span>Regular Node</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #45b7d1;"></div>
            <span>Gateway Node</span>
        </div>
    </div>

    <!-- Recent Activity -->
    <div class="sidebar-section">
        <h6><i class="bi bi-clock-history"></i> Recent Activity</h6>
        <div id="recentActivity" class="recent-activity">
            <small class="text-muted">No recent activity</small>
        </div>
    </div>
{% endcall %}

<!-- D3.js and Network Graph Scripts -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ url_for('static', filename='js/network-graph-live.js') }}"></script>

<script>
let networkGraph;
let isLiveMode = false;
let animationSpeed = 1.0;
let packetSize = 8;
let trailLength = 50;
let activeAnimations = [];
let packetCounter = 0;
let startTime = null;
let liveStats = {
    activeNodes: new Set(),
    packetsPerSecond: 0,
    totalPackets: 0
};

// Initialize the live topology
document.addEventListener('DOMContentLoaded', function() {
    initializeLiveTopology();
    setupEventListeners();
    loadNetworkData();
});

function initializeLiveTopology() {
    console.log('Initializing live topology...');

    // Initialize network graph
    networkGraph = new NetworkGraph('#networkGraph', {
        width: window.innerWidth,
        height: window.innerHeight,
        nodeRadius: 8,
        linkDistance: 100,
        chargeStrength: -300,
        enableZoom: true,
        enableDrag: true
    });

    // Setup controls
    setupEventListeners();
}

function setupEventListeners() {
    // Play/Pause button
    document.getElementById('playPauseBtn').addEventListener('click', toggleLiveMode);

    // Clear animations
    document.getElementById('clearAnimationsBtn').addEventListener('click', clearAllAnimations);

    // Toggle nodes
    document.getElementById('toggleNodesBtn').addEventListener('click', toggleNodes);

    // Settings sliders
    document.getElementById('animationSpeed').addEventListener('input', function(e) {
        animationSpeed = parseFloat(e.target.value);
        document.getElementById('speedValue').textContent = animationSpeed + 'x';
    });

    document.getElementById('packetSize').addEventListener('input', function(e) {
        packetSize = parseInt(e.target.value);
        document.getElementById('sizeValue').textContent = packetSize + 'px';
    });

    document.getElementById('trailLength').addEventListener('input', function(e) {
        trailLength = parseInt(e.target.value);
        document.getElementById('trailValue').textContent = trailLength + '%';
    });

    // Packet filters
    document.getElementById('packetFilterForm').addEventListener('change', function() {
        // Filters will be applied to new packets
        console.log('Packet filters updated');
    });
}

async function loadNetworkData() {
    try {
        showLoading();

        // Load network topology data using the network graph endpoint
        const response = await fetch('/api/network-graph');

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();

        if (data.error) {
            showError(data.error);
            return;
        }

        // Validate data structure
        if (!data.nodes || !Array.isArray(data.nodes)) {
            showError('Invalid network data: missing or invalid nodes');
            return;
        }

        if (!data.links || !Array.isArray(data.links)) {
            showError('Invalid network data: missing or invalid links');
            return;
        }

        // Initialize the network graph with data
        // If we have nodes but no valid links, that's okay - show nodes only
        if (data.nodes && data.nodes.length > 0) {
            networkGraph.loadData(data);
        } else {
            showError('No network nodes found');
        }

        hideLoading();
        console.log('Network data loaded successfully');

    } catch (error) {
        console.error('Error loading network data:', error);
        showError(`Failed to load network data: ${error.message}`);
    }
}

function toggleLiveMode() {
    const button = document.getElementById('playPauseBtn');

    if (isLiveMode) {
        stopLiveMode();
        button.innerHTML = '<i class="bi bi-play-fill"></i> Start Live';
        button.className = 'btn btn-success';
    } else {
        startLiveMode();
        button.innerHTML = '<i class="bi bi-pause-fill"></i> Stop Live';
        button.className = 'btn btn-warning';
    }
}

function startLiveMode() {
    isLiveMode = true;
    startTime = Date.now();

    // Start polling for new packets
    pollForPackets();

    // Start live stats updates
    updateLiveStats();

    console.log('Live mode started');
}

function stopLiveMode() {
    isLiveMode = false;
    clearAllAnimations();
    console.log('Live mode stopped');
}

async function pollForPackets() {
    if (!isLiveMode) return;

    try {
        // Get recent packets (last 5 seconds) using the packets recent API
        const response = await fetch('/api/packets/recent?minutes=1&limit=50');
        const packetsList = await response.json();

        if (packetsList && packetsList.length > 0) {
            processNewPackets(packetsList);
        }

    } catch (error) {
        console.error('Error polling for packets:', error);
    }

    // Continue polling
    setTimeout(pollForPackets, 1000);
}

function processNewPackets(packets) {
    packets.forEach(packet => {
        // Handle both old and new packet formats
        const fromNodeId = packet.from_node_id || packet.src || packet.srcId;
        const toNodeId = packet.to_node_id || packet.dst || packet.dstId;

        // Check if both source and destination nodes exist in the graph
        const sourceNode = networkGraph.getNode(fromNodeId);
        const destNode = networkGraph.getNode(toNodeId);

        if (sourceNode && destNode) {
            // Create packet animation
            createPacketAnimation(sourceNode, destNode, packet);

            // Update stats
            liveStats.activeNodes.add(fromNodeId);
            liveStats.activeNodes.add(toNodeId);
            liveStats.totalPackets++;
            packetCounter++;

            // Update counter display
            document.getElementById('packetCounter').textContent = packetCounter;
        }

        // Handle broadcast packets
        if (toNodeId === 0 || toNodeId === 0xFFFFFFFF) {
            const sourceNode = networkGraph.getNode(fromNodeId);
            if (sourceNode) {
                createBroadcastAnimation(sourceNode, packet);
                liveStats.activeNodes.add(fromNodeId);
                liveStats.totalPackets++;
                packetCounter++;
            }
        }
    });
}

function createPacketAnimation(sourceNode, destNode, packet) {
    // Use the NetworkGraph's built-in animation method
    if (networkGraph && typeof networkGraph.createPacketAnimation === 'function') {
        networkGraph.createPacketAnimation(sourceNode.id, destNode.id, packet);
    } else {
        // Fallback to manual animation if NetworkGraph method not available
        const animation = {
            id: Date.now() + Math.random(),
            source: sourceNode,
            destination: destNode,
            packet: packet,
            element: null,
            startTime: Date.now()
        };

        // Create packet element
        const packetEl = document.createElement('div');
        packetEl.className = 'packet-animation';
        packetEl.style.width = packetSize + 'px';
        packetEl.style.height = packetSize + 'px';
        packetEl.style.left = sourceNode.x + 'px';
        packetEl.style.top = sourceNode.y + 'px';

        document.getElementById('networkGraph').appendChild(packetEl);
        animation.element = packetEl;

        // Animate packet movement
        animatePacket(animation);

        activeAnimations.push(animation);
    }
}

function createBroadcastAnimation(sourceNode, packet) {
    // Use NetworkGraph's pulseNode method for broadcast
    if (networkGraph && typeof networkGraph.pulseNode === 'function') {
        networkGraph.pulseNode(sourceNode.id);
    } else {
        // Fallback to manual pulse
        const nodeElement = networkGraph.getNodeElement(sourceNode.id);
        if (nodeElement) {
            nodeElement.classList.add('node-pulse');
            setTimeout(() => {
                nodeElement.classList.remove('node-pulse');
            }, 500);
        }
    }

    // Add to recent activity
    addRecentActivity(`Broadcast from ${getNodeName(packet.from_node_id)}`);
}

function animatePacket(animation) {
    const duration = 2000 / animationSpeed; // 2 seconds base duration
    const startX = animation.source.x;
    const startY = animation.source.y;
    const endX = animation.destination.x;
    const endY = animation.destination.y;

    const startTime = Date.now();

    function updatePosition() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Easing function for smooth animation
        const easeProgress = 1 - Math.pow(1 - progress, 3);

        const currentX = startX + (endX - startX) * easeProgress;
        const currentY = startY + (endY - startY) * easeProgress;

        animation.element.style.left = currentX + 'px';
        animation.element.style.top = currentY + 'px';

        if (progress < 1) {
            requestAnimationFrame(updatePosition);
        } else {
            // Animation complete
            removeAnimation(animation);
        }
    }

    requestAnimationFrame(updatePosition);
}

function removeAnimation(animation) {
    if (animation.element) {
        animation.element.remove();
    }

    const index = activeAnimations.indexOf(animation);
    if (index > -1) {
        activeAnimations.splice(index, 1);
    }
}

function clearAllAnimations() {
    activeAnimations.forEach(animation => {
        if (animation.element) {
            animation.element.remove();
        }
    });
    activeAnimations = [];
    packetCounter = 0;
    document.getElementById('packetCounter').textContent = '0';
}

function toggleNodes() {
    // Toggle node visibility
    const nodes = document.querySelectorAll('.node');
    nodes.forEach(node => {
        node.style.display = node.style.display === 'none' ? 'block' : 'none';
    });
}

function updateLiveStats() {
    if (!isLiveMode) return;

    // Update active nodes count
    document.getElementById('activeNodesCount').textContent = liveStats.activeNodes.size;

    // Calculate packets per second
    const elapsed = (Date.now() - startTime) / 1000;
    liveStats.packetsPerSecond = elapsed > 0 ? (liveStats.totalPackets / elapsed).toFixed(1) : 0;
    document.getElementById('packetsPerSecond').textContent = liveStats.packetsPerSecond;

    // Update total packets
    document.getElementById('totalPackets').textContent = liveStats.totalPackets;

    // Update live time
    const minutes = Math.floor(elapsed / 60);
    const seconds = Math.floor(elapsed % 60);
    document.getElementById('liveTime').textContent =
        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

    // Continue updating
    setTimeout(updateLiveStats, 1000);
}

function addRecentActivity(activity) {
    const activityEl = document.getElementById('recentActivity');
    const timestamp = new Date().toLocaleTimeString();

    const activityItem = document.createElement('div');
    activityItem.className = 'activity-item';
    activityItem.innerHTML = `<small>${timestamp}: ${activity}</small>`;

    activityEl.insertBefore(activityItem, activityEl.firstChild);

    // Keep only last 10 activities
    const items = activityEl.querySelectorAll('.activity-item');
    if (items.length > 10) {
        items[items.length - 1].remove();
    }
}

function getNodeName(nodeId) {
    // Convert node ID to display name
    return `!${nodeId.toString(16).padStart(8, '0')}`;
}

function showLoading() {
    document.getElementById('loadingSpinner').style.display = 'flex';
}

function hideLoading() {
    document.getElementById('loadingSpinner').style.display = 'none';
}

function showError(message) {
    document.getElementById('graphError').style.display = 'flex';
    document.getElementById('graphError').querySelector('p').textContent = message;
}

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    stopLiveMode();
    clearAllAnimations();
    // Clean up event listeners
    if (networkGraph) {
        networkGraph.cleanup();
    }
});

// Add cleanup method to NetworkGraph class
if (typeof NetworkGraph !== 'undefined') {
    NetworkGraph.prototype.cleanup = function() {
        // Stop any running animations
        if (this.simulation) {
            this.simulation.stop();
        }
        // Clear any timers or intervals
        if (this._gcTimer) {
            clearInterval(this._gcTimer);
        }
    };
}
</script>
{% endblock %}
